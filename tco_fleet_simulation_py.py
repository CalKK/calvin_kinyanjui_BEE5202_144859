# -*- coding: utf-8 -*-
"""TCO_Fleet_Simulation.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WU1M97-OYY9rAJm-5-DoQcNqpxk5JX4H
"""

import numpy as np
import pandas as pd

# 1. GLOBAL SIMULATION PARAMETERS
RIDER_DISTANCE_MEAN = 90.0      # km per day
RIDER_DISTANCE_STD_DEV = 20.0   # km variability
FLEET_SIZE = 100                # bikes per model
SIMULATION_DURATION = 120       # 4 months (days)
BATTERY_EOL_SOH = 0.80          # 80% SOH is the failure point

# Environmental & Technical Constants
AVG_AMBIENT_TEMP = 24.0         # Celsius (Nairobi average)
STRESS_EVENT_PROB = 0.35        # 35% chance of hilly terrain/heavy acceleration
KPLC_TARIFF = 25.0              # KSh per kWh

# 2. MODEL CONFIGURATIONS (48V 30Ah Equivalent)
# SIB parameters derived from prototype data; LFP scaled from the 72V 73Ah log.
MODELS = {
    "SIB_Owned": {
        "mode": "Depot-Charge",
        "capacity_kwh": 1.44,
        "efficiency_wh_km": 20.0,      # Wh/km base
        "initial_cost": 30000.0,       # KSh
        "deg_per_efc": 0.00025,        # 0.025% per cycle (includes chemical stress)
        "int_resistance_base": 0.05,   # Ohms
    },
    "LFP_Owned": {
        "mode": "Depot-Charge",
        "capacity_kwh": 1.44,
        "efficiency_wh_km": 18.0,
        "initial_cost": 45000.0,
        "deg_per_efc": 0.00012,        # 0.012% per cycle (highly stable)
        "int_resistance_base": 0.03,
    },
    "LFP_BaaS": {
        "mode": "BaaS",
        "capacity_kwh": 1.44,
        "efficiency_wh_km": 18.0,
        "cost_per_swap": 200.0,        # KSh
        "swap_threshold": 0.20,        # 20% SOC floor
        "anxiety_window": 0.50,        # 50% SOC anxiety threshold
        "anxiety_prob": 0.25,          # Probabilistic early swap
    }
}

# 3. THE SIMULATION ENGINE
class SimulatedVehicle:
    def __init__(self, vehicle_id, config):
        self.id = vehicle_id
        self.config = config
        self.mode = config["mode"]

        self.total_km = 0.0
        self.total_cost = 0.0
        self.soh = 1.0
        self.is_active = True

        if self.mode == "Depot-Charge":
            self.total_cost += config["initial_cost"]
        else:
            self.current_soc = 1.0
            self.swaps = 0

    def get_dynamic_efficiency(self):
        """
        VOLTAGE SAG MODULE: Accounts for Ohmic losses and battery age.
        """
        # Resistance doubles as SOH hits 80% (Ref: Literature on aging)
        age_multiplier = 1.0 + (1.0 - self.soh) * 5.0

        # Base efficiency
        eff = self.config["efficiency_wh_km"]

        # Check for High-Load/Stress Event (Nairobi traffic/hills)
        if np.random.rand() < STRESS_EVENT_PROB:
            # Voltage sag causes a 15% efficiency penalty (heat loss)
            eff *= 1.15 * age_multiplier

        return eff

    def apply_degradation(self, energy_kwh):
        """
        SOH DEGRADATION MODULE: Uses Equivalent Full Cycle (EFC) throughput.
        """
        efc_today = energy_kwh / self.config["capacity_kwh"]

        # Stress Factor: Rapid discharge or high heat doubles degradation rate
        stress_factor = 1.2 if np.random.rand() < 0.2 else 1.0

        daily_loss = efc_today * self.config["deg_per_efc"] * stress_factor
        self.soh -= daily_loss

        if self.soh < BATTERY_EOL_SOH:
            self.is_active = False
            self.total_cost += self.config["initial_cost"] # Replacement CAPEX
            self.soh = 1.0 # Reset for the new pack
            self.is_active = True

    def run_day(self, km):
        eff = self.get_dynamic_efficiency()
        energy_kwh = (km * eff) / 1000.0

        if self.mode == "Depot-Charge":
            self.total_cost += energy_kwh * KPLC_TARIFF
            self.apply_degradation(energy_kwh)

        elif self.mode == "BaaS":
            soc_used = energy_kwh / self.config["capacity_kwh"]
            self.current_soc -= soc_used

            # Forced Swaps
            while self.current_soc < self.config["swap_threshold"]:
                self.total_cost += self.config["cost_per_swap"]
                self.current_soc += 1.0
                self.swaps += 1

            # Convenience Swaps (Anxiety)
            if self.current_soc < self.config["anxiety_window"]:
                if np.random.rand() < self.config["anxiety_prob"]:
                    self.total_cost += self.config["cost_per_swap"]
                    self.current_soc = 1.0
                    self.swaps += 1

        self.total_km += km

#  4. EXECUTION & TCO REPORTING
def execute():
    # Initialize 3 Fleets
    fleets = {name: [SimulatedVehicle(i, cfg) for i in range(FLEET_SIZE)]
              for name, cfg in MODELS.items()}

    for day in range(SIMULATION_DURATION):
        # Shared workload for comparative integrity
        workloads = np.random.normal(RIDER_DISTANCE_MEAN, RIDER_DISTANCE_STD_DEV, FLEET_SIZE)
        workloads = np.clip(workloads, 0, 250) # Clip negative and extreme values

        for name, fleet in fleets.items():
            for i, vehicle in enumerate(fleet):
                vehicle.run_day(workloads[i])

    # Final Analysis
    print(f"\n{'Model':<15} | {'Total Cost (KSh)':<20} | {'TCO/KM':<10} | {'SOH Avg'}")
    print("-" * 65)
    for name, fleet in fleets.items():
        avg_cost = sum(v.total_cost for v in fleet)
        avg_km = sum(v.total_km for v in fleet)
        avg_soh = sum(v.soh for v in fleet) / FLEET_SIZE if hasattr(fleet[0], 'soh') else 0
        print(f"{name:<15} | {avg_cost:>18,.2f} | {avg_cost/avg_km:>8.2f} | {avg_soh*100:>6.1f}%")

if __name__ == "__main__":
    execute()